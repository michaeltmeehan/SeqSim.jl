

"""
    rand_seq_int(sequence_length::Int; frequencies::Vector{Float64} = fill(0.25, 4)) -> Vector{UInt8}

Generate a random DNA sequence of specified `sequence_length`, encoded as a `Vector{UInt8}` using an internal nucleotide encoding.

This is a lower-level utility function that returns a sequence of integer values in `1:4`, corresponding to 
nucleotides `['A', 'C', 'G', 'T']`, using the provided nucleotide frequencies. The result is converted to 
`UInt8` for memory efficiency and fast indexing in downstream internal routines.

# Arguments
- `sequence_length::Int`: Length of the sequence to generate.
- `frequencies::Vector{Float64}` (optional): Vector of nucleotide probabilities (must sum to 1). 
   Defaults to uniform distribution `[0.25, 0.25, 0.25, 0.25]`.

# Returns
- `Vector{UInt8}`: Internally encoded nucleotide sequence, with values in `1:4`.

# Notes
This function is intended for internal use. Use higher-level constructors or utilities for 
working with human-readable nucleotide sequences.

# Example
```julia
seq = rand_seq_int(20)  # Internal UInt8-encoded DNA sequence of length 20
"""
function rand_seq_int(sequence_length::Int; frequencies::Vector{Float64} = fill(0.25, 4))
    @assert length(frequencies) == 4 "Frequencies must be a vector of length 4."
    @assert sum(frequencies) ≈ 1.0 "Frequencies must sum to 1. Received sum = $(sum(frequencies))"
    @assert all(frequencies .>= 0) "Frequencies must be non-negative. Received frequencies = $frequencies"
    sequence_length > 0 || throw(ArgumentError("Sequence length must be positive."))
    d = Categorical(frequencies)
    seq = rand(d, sequence_length)
    return UInt8.(seq)  # Convert to UInt8
end


"""
    rand_seq(sequence_length::Int; frequencies::Vector{Float64} = fill(0.25, 4), data::Union{Nothing, Dict} = nothing) -> Sequence

Generate a random DNA sequence of the specified `sequence_length` as a high-level `Sequence` object.

The sequence is generated by sampling nucleotides `['A', 'C', 'G', 'T']` according to the given frequency vector.
Internally, nucleotides are encoded as `UInt8` values using the mapping `1 => 'A', 2 => 'C', 3 => 'G', 4 => 'T'`.

Optional metadata such as `id`, `time`, or `metadata` can be provided via the `data` dictionary. These fields
are matched against the `Sequence` type's field names and applied automatically.

# Arguments
- `sequence_length::Int`: Length of the sequence to generate.
- `frequencies::Vector{Float64}` (optional): Vector of nucleotide probabilities (must sum to 1). Defaults to `[0.25, 0.25, 0.25, 0.25]`.
- `data::Union{Nothing, Dict}` (optional): Dictionary of metadata fields (e.g. `:id`, `:time`, `:metadata`) to populate the resulting `Sequence`.

# Returns
- `Sequence`: A complete `Sequence` object containing the random nucleotide sequence and any supplied metadata.

# Example
```julia
seq = rand_seq(30, data=Dict(:id => "sample1", :time => 1.2))
"""
function rand_seq(sequence_length::Int; frequencies::Vector{Float64} = fill(0.25, 4), data::Union{Nothing, Dict}=nothing)::Sequence
    sequence = rand_seq_int(sequence_length; frequencies=frequencies)
    sequence = Sequence(sequence)
    if !isnothing(data)
        for field in fieldnames(Sequence)
            if haskey(data, field)
                setfield!(sequence, field, data[field])
            end
        end
    end
    return sequence
end


"""
    update_transition_weights!(transition_weights::Vector{Matrix{Float64}}, 
                               Δt::Float64, 
                               μ::Vector{Float64}, 
                               λ::SVector{4, Float64}, 
                               V::SMatrix{4,4,Float64}, 
                               V⁻¹::SMatrix{4,4,Float64})::Vector{Matrix{Float64}}

Updates the transition weight matrices in-place for a set of categories based on the given parameters.

# Arguments
- `transition_weights::Vector{Matrix{Float64}}`: A vector of matrices representing the transition weights for each category. These matrices are updated in-place.
- `Δt::Float64`: The time interval over which the transition weights are updated.
- `μ::Vector{Float64}`: A vector of mutation rates, one for each category.
- `λ::SVector{4, Float64}`: A static vector representing the eigenvalues of the rate matrix.
- `V::SMatrix{4,4,Float64}`: A static matrix representing the eigenvectors of the rate matrix.
- `V⁻¹::SMatrix{4,4,Float64}`: A static matrix representing the inverse of the eigenvector matrix `V`.

# Returns
- `Vector{Matrix{Float64}}`: The updated `transition_weights` vector (same object as the input, modified in-place).

# Details
For each category, the function computes the updated transition weight matrix using the formula:

    `transition_weights[cat] .= V * Diagonal(exp.(μ[cat] * λ * Δt)) * V⁻¹`

This formula applies the matrix exponential of the scaled eigenvalues to compute the transition probabilities over the given time interval `Δt`.

# Notes
- The function modifies the `transition_weights` vector in-place, so the input object is directly updated.
- The use of static arrays (`SVector` and `SMatrix`) for `λ`, `V`, and `V⁻¹` ensures efficient computation for small fixed-size matrices.
"""
function update_transition_weights!(transition_weights::Vector{Matrix{Float64}}, 
                                    Δt::Float64, 
                                    μ::Vector{Float64}, 
                                    λ::SVector{4, Float64}, 
                                    V::SMatrix{4,4,Float64}, 
                                    V⁻¹::SMatrix{4,4,Float64})::Vector{Matrix{Float64}}
    for cat in eachindex(transition_weights)
        transition_weights[cat] = V * Diagonal(exp.((μ[cat] * Δt) .* λ)) * V⁻¹    # TODO: Replace with V * (exp.(μ[cat] * λ * Δt) .* V⁻¹)
        # if !all(sum(transition_weights[cat], dims=1) .≈ 1.0)
        #     @warn "Transition weights for category $cat do not sum to 1.0."
        #     for col in eachcol(transition_weights[cat])
        #         col_sum = sum(col)
        #         if !isapprox(col_sum, 1.0; atol=1e-10)
        #             @warn "Column $col in transition_weights[$cat] does not sum to 1.0 (sum = $col_sum). Renormalizing."
        #             transition_weights[cat][:, col] ./= col_sum
        #         end
        #     end
        # end
    end
    return transition_weights
end


"""
    update_site(nucl_in::UInt8, weights::Matrix{Float64})::UInt8

Updates a nucleotide site based on a given transition probability matrix.

# Arguments
- `nucl_in::UInt8`: The current nucleotide represented as an unsigned 8-bit integer.
- `weights::Matrix{Float64}`: A matrix of transition probabilities where each entry `weights[i, j]` 
  represents the probability of transitioning from nucleotide `j` to nucleotide `i`.

# Returns
- `UInt8`: The updated nucleotide after applying the transition probabilities.

# Details
The function generates a random number `r` and iteratively accumulates probabilities from the 
`weights` matrix until `r` is less than the accumulated probability. The index of the accumulated 
probability determines the new nucleotide.

# Notes
- The input `weights` matrix is assumed to be properly normalized such that the sum of probabilities 
  for each column equals 1.
- The function uses 1-based indexing, consistent with Julia's array indexing.
"""
@inline function update_site(nucl_in::UInt8, weights::Matrix{Float64})::UInt8
    r = rand()
    prob = weights[1, nucl_in]
    nucl_out = UInt8(1)
    while r ≥ prob
        nucl_out += 1
        prob += weights[nucl_out, nucl_in]
    end
    return nucl_out
end


"""
    update_sequence!(transition_weights::Vector{Matrix{Float64}}, 
                     seq_in::Vector{UInt8}, 
                     Δt::Float64, 
                     μ::Vector{Float64},
                     variable_sites::Vector{Vector{Int64}},
                     λ::SVector{4, Float64},
                     V::SMatrix{4,4,Float64},
                     V⁻¹::SMatrix{4,4,Float64})::Vector{UInt8}

Updates a nucleotide sequence based on a given set of transition weights and evolutionary parameters.

# Arguments
- `transition_weights::Vector{Matrix{Float64}}`: A vector of transition weight matrices, one for each category.
- `seq_in::Vector{UInt8}`: The input nucleotide sequence represented as a vector of `UInt8` values.
- `Δt::Float64`: The time interval over which the sequence evolves.
- `μ::Vector{Float64}`: A vector of mutation rates for each category.
- `variable_sites::Vector{Vector{Int64}}`: A vector where each element is a list of indices representing variable sites for a specific category.
- `λ::SVector{4, Float64}`: A static vector of eigenvalues for the substitution model.
- `V::SMatrix{4,4,Float64}`: A static matrix of eigenvectors for the substitution model.
- `V⁻¹::SMatrix{4,4,Float64}`: The inverse of the eigenvector matrix `V`.

# Returns
- `Vector{UInt8}`: The updated nucleotide sequence after applying the transition weights and evolutionary parameters.

# Details
This function simulates the evolution of a nucleotide sequence over a given time interval (`Δt`). It updates the sequence by iterating over each category of sites and applying the corresponding transition weights to the variable sites. The transition weights are updated using the `update_transition_weights!` function, which incorporates the evolutionary parameters (`λ`, `V`, `V⁻¹`, and `μ`).

Each site in the sequence is updated using the `update_site` function, which determines the new nucleotide state based on the current state and the transition probabilities.

# Note
The function assumes that the input sequence (`seq_in`) and the transition weights are properly initialized and consistent with the provided evolutionary parameters.
"""
function update_sequence!(transition_weights::Vector{Matrix{Float64}}, 
                          seq_in::Vector{UInt8}, 
                          Δt::Float64, 
                          μ::Vector{Float64},
                          variable_sites::Vector{Vector{Int64}},
                          λ::SVector{4, Float64},
                          V::SMatrix{4,4,Float64},
                          V⁻¹::SMatrix{4,4,Float64})::Vector{UInt8}
    seq_out = copy(seq_in)
    transition_weights = update_transition_weights!(transition_weights, Δt, μ, λ, V, V⁻¹)
    for cat in eachindex(μ)
        weights = transition_weights[cat]
        for idx in variable_sites[cat]
            seq_out[idx] = update_site(seq_in[idx], weights)
        end
    end
    return seq_out
end


function update_sequence!(sequence::Sequence, site_model::SiteModel, Δt::Float64)
    # Extract parameters from the site model
    variable_sites = site_model.variable_sites
    μ = site_model.μ
    λ = site_model.substitution_model.λ
    V = site_model.substitution_model.V
    V⁻¹ = site_model.substitution_model.V⁻¹

    # Initialize transition weights for each category
    transition_weights = [zeros(4, 4) for _ in 1:site_model.gamma_category_count]

    # Update the sequence using the transition weights and parameters
    updated_sequence = update_sequence!(transition_weights, sequence.sequence, Δt, μ, variable_sites, λ, V, V⁻¹)

    # Update the sequence object with the new sequence
    sequence.sequence = updated_sequence

    return sequence
end